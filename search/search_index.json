{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Skeleton Application This document consists of the following parts: Introduction Getting started Different template types Developing the Skeleton App ApiService More tools This documentation is intended for front-end developers with an understanding of the following technologies: HTML / CSS / JavaScript TypeScript React Gatsby Command Line Interface And know how to use these tools: Docker Desktop NodeJS Node Package Manager Introduction The skeleton application is designed for rapid application testing and prototype development on the NL Design System . There are several templates you can use as a running start - - each with their own functionality and purpose. Website : A simple website skeleton, including header, footers, routing and more. Does not initiate authentication. Choose this option without the need for a back end. Of course, you can add it yourself later. PIP : It provides a basic skeleton application with full NL Design System functionality that any developer can easily extend, view locally, and deploy to an online environment for demonstration purposes. It has Common Gateway support, multiple navigations and much more. Choose this option for built-in authentication. _Dashboard: Coming Soon_ NOTE : Both the PIP template and the Dashboard need a back end Getting started You can find the repository for this application here . Cloning this repository to your machine is the next step. You can do this by clicking the green button, downloading the ZIP format, and unzipping in your preferred folder or use the following set of commands: In your command line interface, in the correct directory: git clone https://github.com/ConductionNL/skeleton-app.git cd skeleton-app That's all for an initial setup Chosing a template Navigate to the root folder of the repository you just downloaded. Open your preferred terminal and execute: cd pwa npm install npm start Navigate in your browser to localhost:8000 and you are welcomed to the template choosing section. Check out the live implementations and select your templated based on desired functionality. Follow the installation instructions. Spinning up the Skeleton App The skeleton app is built with GatsbyJs. Knowledge of this framework is recommended but not required. For full functionality with logging in (PIP template, for instance), you will need to spin up the back-end along with the front-end. It is unnecessary to continue with the website templating section of the Skeleton App. Depending on the development, these steps require you to: Spin up the front-end of the application . Spin up the backend With the front end running on localhost:8000 , you are now ready to develop the Skeleton App. On the left-side navigation, you can opt for: Adding pages Components ApiService (back-end needed) Forms Accessing and editing this documentation You can access this documentation with mkdocs . For first-timers accessing this excellent documentation tool. This tool is installed by default. Head over to localhost:8000 to see this document locally. NOTE : Mkdocs can't run on any other port by default. It's recommended first to run the documentation and then Gatsby . Gatsby also defaults to port localhost:8000 , but asks to run at localhost:8001 if 8000 is unavailable. Mkdocs errors in that scenario.","title":"Introduction skeleton-app"},{"location":"#skeleton-application","text":"This document consists of the following parts: Introduction Getting started Different template types Developing the Skeleton App ApiService More tools This documentation is intended for front-end developers with an understanding of the following technologies: HTML / CSS / JavaScript TypeScript React Gatsby Command Line Interface And know how to use these tools: Docker Desktop NodeJS Node Package Manager","title":"Skeleton Application"},{"location":"#introduction","text":"The skeleton application is designed for rapid application testing and prototype development on the NL Design System . There are several templates you can use as a running start - - each with their own functionality and purpose. Website : A simple website skeleton, including header, footers, routing and more. Does not initiate authentication. Choose this option without the need for a back end. Of course, you can add it yourself later. PIP : It provides a basic skeleton application with full NL Design System functionality that any developer can easily extend, view locally, and deploy to an online environment for demonstration purposes. It has Common Gateway support, multiple navigations and much more. Choose this option for built-in authentication. _Dashboard: Coming Soon_ NOTE : Both the PIP template and the Dashboard need a back end","title":"Introduction"},{"location":"#getting-started","text":"You can find the repository for this application here . Cloning this repository to your machine is the next step. You can do this by clicking the green button, downloading the ZIP format, and unzipping in your preferred folder or use the following set of commands: In your command line interface, in the correct directory: git clone https://github.com/ConductionNL/skeleton-app.git cd skeleton-app That's all for an initial setup","title":"Getting started"},{"location":"#chosing-a-template","text":"Navigate to the root folder of the repository you just downloaded. Open your preferred terminal and execute: cd pwa npm install npm start Navigate in your browser to localhost:8000 and you are welcomed to the template choosing section. Check out the live implementations and select your templated based on desired functionality. Follow the installation instructions.","title":"Chosing a template"},{"location":"#spinning-up-the-skeleton-app","text":"The skeleton app is built with GatsbyJs. Knowledge of this framework is recommended but not required. For full functionality with logging in (PIP template, for instance), you will need to spin up the back-end along with the front-end. It is unnecessary to continue with the website templating section of the Skeleton App. Depending on the development, these steps require you to: Spin up the front-end of the application . Spin up the backend With the front end running on localhost:8000 , you are now ready to develop the Skeleton App. On the left-side navigation, you can opt for: Adding pages Components ApiService (back-end needed) Forms","title":"Spinning up the Skeleton App"},{"location":"#accessing-and-editing-this-documentation","text":"You can access this documentation with mkdocs . For first-timers accessing this excellent documentation tool. This tool is installed by default. Head over to localhost:8000 to see this document locally. NOTE : Mkdocs can't run on any other port by default. It's recommended first to run the documentation and then Gatsby . Gatsby also defaults to port localhost:8000 , but asks to run at localhost:8001 if 8000 is unavailable. Mkdocs errors in that scenario.","title":"Accessing and editing this documentation"},{"location":"apiService/","text":"Development of the Skeleton Application This page consists of the following parts: Adding an API Adding an exiting API Adding an API to the gateway API service Adding a existing API If you want to use an API thats already avaliable to your application, you need to add the base URL of your API to the .env file in src/static . This is done by adding a variable and value like this: window.sessionStorage.setItem(\"CATFACTS_BASEURL\", \"https://cat-fact.herokuapp.com\"); . To create a client, open pwa/src/apiService/apiService.ts and add a new client like the example below: public get CatClient(): AxiosInstance { return axios.create({ baseURL: window.sessionStorage.getItem(\"CATFACTS_BASEURL\") ?? \"\" }); } Add headers when needed: public get CatClient(): AxiosInstance { return axios.create({ baseURL: window.sessionStorage.getItem(\"CATFACTS_BASEURL\") ?? \"\", headers: { Accept: \"application/json\", \"Content-Type\": \"application/json\", Authorization: \"Bearer \" + this.getJWT(), }, }); } Let's create a resource for the client. First, we copy the contents of the example.ts from the /apiService/resources/ folder. Create a file and paste the content you copied earlier and name the new file to somethin like catFacts.ts . Uncomment all code. Rename the class name as well. If you used the suggested catFacts.ts you will end up with export default class CatFacts { . The endpoint also needs to be changed to the proper endpoint (example: } = await Send(this._instance, \"GET\", \"/facts\"); ). To connect the created resource to the created client, create a new function in the apiService.ts // /src/apiService/apiService.ts public get CatFacts(): Catfacts { return new CatFacts(this.CatClient); } The hook here is needed for caching the API resources(Cacheing the results is the only function of the hook, you could also just use the response of the call itself within the application; might be good when your API is very fast, or when you have to pay per request). You are ready to go to use this API in your app. Read fetching and saving data . Adding an API To be able to send the form and to show the data in the table we need an API that can handle this. In this guide you can add an exiting API to the skeleton-app. This guide also explains how to create an API with Stoplight Adding an API to the Common Gateway If there's and OAS.yaml in the root of your repository the Common Gateway, the Gateway will automatically find this and can be found under localhost:8000/endpoints . Adding an API to the ApiService The Skeleton Application does API handling via the apiService in the application. The service is built on axios to fetch API data. Using this service saves many lines of code by calling upon methods in the component classes. You can find the ApiService at pwa/src/apiService/apiService.ts folder and structured with resources and services. Specific services such as logging are placed in services, and other calls are stored in resources. If we added the API we can create a resource in cd pwa/src/apiService/resources or service in cd pwa/src/apiService/services We will create a resource file with getAll and create functions touch pwa/src/resource/example.ts` The example shown is the Notifications resource: // /src/apiService/resource/example.ts import { Send } from \"../apiService\"; import { AxiosInstance } from \"axios\"; export default class Example { private _instance: AxiosInstance; constructor(_instance: AxiosInstance) { this._instance = _instance; } public getAll = async (): Promise<any> => { const { data: { results }, } = await Send(this._instance, \"GET\", \"/notifications\"); return results; }; public create = async (variables: { payload: any }): Promise<any> => { const { payload } = variables; const { data } = await Send(this._instance, \"POST\", \"/notifications\", payload); return data; }; } Then in apiService.ts you need to add your resource // /src/apiService/resource/example.ts // Resources import Example from \"./resources/example\"; // Resources public get Example(): Example { return new Example(this.apiClient); } Now to create a hook for the caching we talked about earlier. For the keen observer, there's some error handling as well. Add a new page to /src/hooks with the following code: // /src/hooks/example.ts import * as React from \"react\"; import { QueryClient, useMutation, useQuery } from \"react-query\"; import APIService from \"../apiService/apiService\"; import { navigate } from \"gatsby-link\"; import { addItem } from \"../services/mutateQueries\"; import APIContext from \"../apiService/apiContext\"; export const useExample = (queryClient: QueryClient) => { const API: APIService = React.useContext(APIContext); const getAll = () => useQuery<any[], Error>(\"examples\", API.Example.getAll, { onError: (error) => { throw new Error(error.message); } }); const create = () => useMutation<any, Error, any>(API.Example.create, { onSuccess: async (newNotification) => { addItem(queryClient, \"notifications\", newNotification); navigate(\"/testFolder\"); }, onError: (error) => { throw new Error(error.message); } }); return { getAll, create }; }; Then to handle the form, go to /src/templates/test/TestDetailTemplate and add/edit the following things // /src/templates/test/TestDetailTemplate.tsx const queryClient = useQueryClient(); const _useExample = useExample(queryClient); const createExample = _useExample.create(); const { register, handleSubmit, formState: { errors }, setValue } = useForm(); React.useEffect(() => { example && handleSetFormValues(example); }, [example]); const handleSetFormValues = (formValues: ITestDetail): void => { setValue(\"title\", formValues.title); setValue(\"description\", formValues.description); }; const onSubmit = (data: any) => { createExample.mutate({ payload: data }); }; // form created -> show result // add queryclient to the table -> show the result NEXT STEP","title":"ApiService"},{"location":"apiService/#development-of-the-skeleton-application","text":"This page consists of the following parts: Adding an API Adding an exiting API Adding an API to the gateway API service","title":"Development of the Skeleton Application"},{"location":"apiService/#adding-a-existing-api","text":"If you want to use an API thats already avaliable to your application, you need to add the base URL of your API to the .env file in src/static . This is done by adding a variable and value like this: window.sessionStorage.setItem(\"CATFACTS_BASEURL\", \"https://cat-fact.herokuapp.com\"); . To create a client, open pwa/src/apiService/apiService.ts and add a new client like the example below: public get CatClient(): AxiosInstance { return axios.create({ baseURL: window.sessionStorage.getItem(\"CATFACTS_BASEURL\") ?? \"\" }); } Add headers when needed: public get CatClient(): AxiosInstance { return axios.create({ baseURL: window.sessionStorage.getItem(\"CATFACTS_BASEURL\") ?? \"\", headers: { Accept: \"application/json\", \"Content-Type\": \"application/json\", Authorization: \"Bearer \" + this.getJWT(), }, }); } Let's create a resource for the client. First, we copy the contents of the example.ts from the /apiService/resources/ folder. Create a file and paste the content you copied earlier and name the new file to somethin like catFacts.ts . Uncomment all code. Rename the class name as well. If you used the suggested catFacts.ts you will end up with export default class CatFacts { . The endpoint also needs to be changed to the proper endpoint (example: } = await Send(this._instance, \"GET\", \"/facts\"); ). To connect the created resource to the created client, create a new function in the apiService.ts // /src/apiService/apiService.ts public get CatFacts(): Catfacts { return new CatFacts(this.CatClient); } The hook here is needed for caching the API resources(Cacheing the results is the only function of the hook, you could also just use the response of the call itself within the application; might be good when your API is very fast, or when you have to pay per request). You are ready to go to use this API in your app. Read fetching and saving data .","title":"Adding a existing API"},{"location":"apiService/#adding-an-api","text":"To be able to send the form and to show the data in the table we need an API that can handle this. In this guide you can add an exiting API to the skeleton-app. This guide also explains how to create an API with Stoplight","title":"Adding an API"},{"location":"apiService/#adding-an-api-to-the-common-gateway","text":"If there's and OAS.yaml in the root of your repository the Common Gateway, the Gateway will automatically find this and can be found under localhost:8000/endpoints .","title":"Adding an API to the Common Gateway"},{"location":"apiService/#adding-an-api-to-the-apiservice","text":"The Skeleton Application does API handling via the apiService in the application. The service is built on axios to fetch API data. Using this service saves many lines of code by calling upon methods in the component classes. You can find the ApiService at pwa/src/apiService/apiService.ts folder and structured with resources and services. Specific services such as logging are placed in services, and other calls are stored in resources. If we added the API we can create a resource in cd pwa/src/apiService/resources or service in cd pwa/src/apiService/services We will create a resource file with getAll and create functions touch pwa/src/resource/example.ts` The example shown is the Notifications resource: // /src/apiService/resource/example.ts import { Send } from \"../apiService\"; import { AxiosInstance } from \"axios\"; export default class Example { private _instance: AxiosInstance; constructor(_instance: AxiosInstance) { this._instance = _instance; } public getAll = async (): Promise<any> => { const { data: { results }, } = await Send(this._instance, \"GET\", \"/notifications\"); return results; }; public create = async (variables: { payload: any }): Promise<any> => { const { payload } = variables; const { data } = await Send(this._instance, \"POST\", \"/notifications\", payload); return data; }; } Then in apiService.ts you need to add your resource // /src/apiService/resource/example.ts // Resources import Example from \"./resources/example\"; // Resources public get Example(): Example { return new Example(this.apiClient); } Now to create a hook for the caching we talked about earlier. For the keen observer, there's some error handling as well. Add a new page to /src/hooks with the following code: // /src/hooks/example.ts import * as React from \"react\"; import { QueryClient, useMutation, useQuery } from \"react-query\"; import APIService from \"../apiService/apiService\"; import { navigate } from \"gatsby-link\"; import { addItem } from \"../services/mutateQueries\"; import APIContext from \"../apiService/apiContext\"; export const useExample = (queryClient: QueryClient) => { const API: APIService = React.useContext(APIContext); const getAll = () => useQuery<any[], Error>(\"examples\", API.Example.getAll, { onError: (error) => { throw new Error(error.message); } }); const create = () => useMutation<any, Error, any>(API.Example.create, { onSuccess: async (newNotification) => { addItem(queryClient, \"notifications\", newNotification); navigate(\"/testFolder\"); }, onError: (error) => { throw new Error(error.message); } }); return { getAll, create }; }; Then to handle the form, go to /src/templates/test/TestDetailTemplate and add/edit the following things // /src/templates/test/TestDetailTemplate.tsx const queryClient = useQueryClient(); const _useExample = useExample(queryClient); const createExample = _useExample.create(); const { register, handleSubmit, formState: { errors }, setValue } = useForm(); React.useEffect(() => { example && handleSetFormValues(example); }, [example]); const handleSetFormValues = (formValues: ITestDetail): void => { setValue(\"title\", formValues.title); setValue(\"description\", formValues.description); }; const onSubmit = (data: any) => { createExample.mutate({ payload: data }); }; // form created -> show result // add queryclient to the table -> show the result","title":"Adding an API to the ApiService"},{"location":"apiService/#next-step","text":"","title":"NEXT STEP"},{"location":"backend/","text":"Back end Spinning up the backend in only needed in the following scenario's: ApiService Submitting forms Authenticating users We integrated another open source project called Common Gateway to authenticate and connect to APIs. This gateway allows us to define how to authenticate to external APIs and help with user authentication. Spinning up the back end With the front-end running in port:8000 , change directory out of the folder to the root of your repo. With Docker Desktop running, execute in the Command Line Interface: docker-compose pull docker-compose up These commands will automatically download the containers needed for the application's backend. You will need to keep this running as well. If you are done developing the application, you can stop them in Docker Desktop. Allow Docker the time to pull all the containers required. After a few minutes, the command line interface will display a ready to handle connections message in the CLI.","title":"Back end"},{"location":"backend/#back-end","text":"Spinning up the backend in only needed in the following scenario's: ApiService Submitting forms Authenticating users We integrated another open source project called Common Gateway to authenticate and connect to APIs. This gateway allows us to define how to authenticate to external APIs and help with user authentication.","title":"Back end"},{"location":"backend/#spinning-up-the-back-end","text":"With the front-end running in port:8000 , change directory out of the folder to the root of your repo. With Docker Desktop running, execute in the Command Line Interface: docker-compose pull docker-compose up These commands will automatically download the containers needed for the application's backend. You will need to keep this running as well. If you are done developing the application, you can stop them in Docker Desktop. Allow Docker the time to pull all the containers required. After a few minutes, the command line interface will display a ready to handle connections message in the CLI.","title":"Spinning up the back end"},{"location":"components/","text":"Components This page consists of the following parts: Using packages Adding components Basic table Basic form Multistep form Form.io API service Using packages The Skeleton app is designed to be modular to save on development time. One of the aspects of this is the compatibility to use components developed by different players in various ecosystems. One of the NL Design System players is the municipality of The Hague. These components work exceptionally well with the PIP template. Now, with added pages, let's add some components. The components we're using are in the conduction-components package and the gemeente-denhaag package . these packages are already included in package.json and can be used right away. @TODO more info view, use, and add packages Adding components This guide shows you how to add common page elements like tables and forms to your pages. After that, all will be tied together by submitting the form and rendering the data in a table. Assuming imports are known to the readereadereader and React hooks and TypeScript interfaces. If any of the examples below are unclear, please revisit the requirements on the home page of the documentation or the glossary . Basic table First, let's add the table to /src/templates/test/testDetailPage.tsx . Doing this is like any other component with React and TypeScript. // /src/templates/test/testDetailPage.tsx import * as React from \"react\"; import { Button, Heading3 } from \"@gemeente-denhaag/components-react\"; import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from \"@gemeente-denhaag/table\"; export const HomeTemplate: React.FC = () => { return ( <div> <div> <Heading3>Meldingen</Heading3> <Table> <TableHead> <TableRow> <TableHeader>Titel</TableHeader> <TableHeader>Omschrijving</TableHeader> <TableHeader>Datum</TableHeader> <TableHeader><Button>Melding doen</Button></TableHeader> </TableRow> </TableHead> <TableBody> <TableRow> <TableCell>Test melding</TableCell> <TableCell>Dit is een test melding</TableCell> <TableCell>01-01-2022</TableCell> <TableCell/> </TableRow> </TableBody> </Table> </div> </div> ); }; Navigate to localhost:8000 en click on the sideNav item '[your-example-name] page'. You should see this: Basic form Then add the form /src/templates/test/TestDetailTemplate.tsx // /src/templates/test/TestDetailTemplate.tsx import * as React from \"react\"; import { useForm } from \"react-hook-form\"; import { Button, FormField, FormFieldInput, FormFieldLabel } from \"@gemeente-denhaag/components-react\"; import { useTranslation } from \"react-i18next\"; import { InputText, Textarea } from \"@conduction/components\"; interface ITestDetail { title: string; description: string; } interface TestDetailProps { example?: ITestDetail; } export const TestDetailTemplate: React.FC<TestDetailProps> = ({ example }) => { const { register, handleSubmit, formState: { errors }, setValue } = useForm(); //the empty onSubmit is dependent on an API to function. This API is not yet implemented const onSubmit = async () => {}; return ( <form onSubmit={handleSubmit(onSubmit)}> <FormField> <FormFieldInput> <FormFieldLabel>Titel</FormFieldLabel> <InputText {...{ register, errors }} validation={{ required: true }} name=\"title\" /> </FormFieldInput> </FormField> <FormField> <FormFieldInput> <FormFieldLabel>Omschrijving</FormFieldLabel> <Textarea {...{ register, errors }} name=\"message\" validation={{ required: true }} /> </FormFieldInput> </FormField> <Button size=\"large\" type=\"submit\"> Verzenden </Button> </form> ); }; Now, to link the table to the form Edit the button in the table to: // /src/templates/test/TestTemplate.tsx <Button onClick={() => navigate(\"/testFolder/testDetail\")}>Melding doen</Button> Click on the button. The view should see this: Multistep forms Forms are an important aspect of web development. How else can applications catch user input and make it much easier for users to submit their information without needing to leave the comfort of their homes? Below is a demonstration of how to implement a form. The tool used to add (multistep) forms is called Form.io . This handy tool will save time on developing (good) forms. All forms rendered within the Form.io platform are done using a JSON Schema. This schema is used to tell the renderer how to render the form, but also provides a way for the API to automatically be generated to support the form. This documentation provides detailed specifications over the structure of the Form JSON Schema and a component that can be rendered with a Form. If you reached this part of the documentation, you should have at least one page made so far. If not, you can always go back and read this again. Below is an example of the minimum requirements for a form made with form.io. Writing the JSON schema for your form all by yourself is pretty extensive, so using a generator is recommended. We save hours by using this useful tool . Build a form by dragging the elements; a Form JSON is generated below. Copy this JSON and replace the Paste here the JSON schema comment. Rebuild the server to be sure and view your form in the browser on localhost:8000 import * as React from \"react\"; const FormIOPage: React.FC = () => { const [formIO, setFormIO] = React.useState<any>(null); const formIOSchema = { // Paste here the JSON schema }; React.useEffect(() => { if (formIO) return; import(\"@formio/react\").then((formio) => { const { Form } = formio; setFormIO(<Form src={formIOSchema} onSubmit={console.log} />); // replace the codeblock here send send the form input elsewhere }); }, [formIO]); return <>{formIO && formIO}</>; }; export default FormIOPage; Once you have filled your form with data, submit it and verify the inputs in the browser console. To handle the input differently, alter the onSubmit code block in the useEffect hook. Adding an API to the ApiService Now that you've added the components tie it together in the following guide click here to see the guide .","title":"Components"},{"location":"components/#components","text":"This page consists of the following parts: Using packages Adding components Basic table Basic form Multistep form Form.io API service","title":"Components"},{"location":"components/#using-packages","text":"The Skeleton app is designed to be modular to save on development time. One of the aspects of this is the compatibility to use components developed by different players in various ecosystems. One of the NL Design System players is the municipality of The Hague. These components work exceptionally well with the PIP template. Now, with added pages, let's add some components. The components we're using are in the conduction-components package and the gemeente-denhaag package . these packages are already included in package.json and can be used right away. @TODO more info view, use, and add packages","title":"Using packages"},{"location":"components/#adding-components","text":"This guide shows you how to add common page elements like tables and forms to your pages. After that, all will be tied together by submitting the form and rendering the data in a table. Assuming imports are known to the readereadereader and React hooks and TypeScript interfaces. If any of the examples below are unclear, please revisit the requirements on the home page of the documentation or the glossary .","title":"Adding components"},{"location":"components/#basic-table","text":"First, let's add the table to /src/templates/test/testDetailPage.tsx . Doing this is like any other component with React and TypeScript. // /src/templates/test/testDetailPage.tsx import * as React from \"react\"; import { Button, Heading3 } from \"@gemeente-denhaag/components-react\"; import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from \"@gemeente-denhaag/table\"; export const HomeTemplate: React.FC = () => { return ( <div> <div> <Heading3>Meldingen</Heading3> <Table> <TableHead> <TableRow> <TableHeader>Titel</TableHeader> <TableHeader>Omschrijving</TableHeader> <TableHeader>Datum</TableHeader> <TableHeader><Button>Melding doen</Button></TableHeader> </TableRow> </TableHead> <TableBody> <TableRow> <TableCell>Test melding</TableCell> <TableCell>Dit is een test melding</TableCell> <TableCell>01-01-2022</TableCell> <TableCell/> </TableRow> </TableBody> </Table> </div> </div> ); }; Navigate to localhost:8000 en click on the sideNav item '[your-example-name] page'. You should see this:","title":"Basic table"},{"location":"components/#basic-form","text":"Then add the form /src/templates/test/TestDetailTemplate.tsx // /src/templates/test/TestDetailTemplate.tsx import * as React from \"react\"; import { useForm } from \"react-hook-form\"; import { Button, FormField, FormFieldInput, FormFieldLabel } from \"@gemeente-denhaag/components-react\"; import { useTranslation } from \"react-i18next\"; import { InputText, Textarea } from \"@conduction/components\"; interface ITestDetail { title: string; description: string; } interface TestDetailProps { example?: ITestDetail; } export const TestDetailTemplate: React.FC<TestDetailProps> = ({ example }) => { const { register, handleSubmit, formState: { errors }, setValue } = useForm(); //the empty onSubmit is dependent on an API to function. This API is not yet implemented const onSubmit = async () => {}; return ( <form onSubmit={handleSubmit(onSubmit)}> <FormField> <FormFieldInput> <FormFieldLabel>Titel</FormFieldLabel> <InputText {...{ register, errors }} validation={{ required: true }} name=\"title\" /> </FormFieldInput> </FormField> <FormField> <FormFieldInput> <FormFieldLabel>Omschrijving</FormFieldLabel> <Textarea {...{ register, errors }} name=\"message\" validation={{ required: true }} /> </FormFieldInput> </FormField> <Button size=\"large\" type=\"submit\"> Verzenden </Button> </form> ); }; Now, to link the table to the form Edit the button in the table to: // /src/templates/test/TestTemplate.tsx <Button onClick={() => navigate(\"/testFolder/testDetail\")}>Melding doen</Button> Click on the button. The view should see this:","title":"Basic form"},{"location":"components/#multistep-forms","text":"Forms are an important aspect of web development. How else can applications catch user input and make it much easier for users to submit their information without needing to leave the comfort of their homes? Below is a demonstration of how to implement a form. The tool used to add (multistep) forms is called Form.io . This handy tool will save time on developing (good) forms. All forms rendered within the Form.io platform are done using a JSON Schema. This schema is used to tell the renderer how to render the form, but also provides a way for the API to automatically be generated to support the form. This documentation provides detailed specifications over the structure of the Form JSON Schema and a component that can be rendered with a Form. If you reached this part of the documentation, you should have at least one page made so far. If not, you can always go back and read this again. Below is an example of the minimum requirements for a form made with form.io. Writing the JSON schema for your form all by yourself is pretty extensive, so using a generator is recommended. We save hours by using this useful tool . Build a form by dragging the elements; a Form JSON is generated below. Copy this JSON and replace the Paste here the JSON schema comment. Rebuild the server to be sure and view your form in the browser on localhost:8000 import * as React from \"react\"; const FormIOPage: React.FC = () => { const [formIO, setFormIO] = React.useState<any>(null); const formIOSchema = { // Paste here the JSON schema }; React.useEffect(() => { if (formIO) return; import(\"@formio/react\").then((formio) => { const { Form } = formio; setFormIO(<Form src={formIOSchema} onSubmit={console.log} />); // replace the codeblock here send send the form input elsewhere }); }, [formIO]); return <>{formIO && formIO}</>; }; export default FormIOPage; Once you have filled your form with data, submit it and verify the inputs in the browser console. To handle the input differently, alter the onSubmit code block in the useEffect hook.","title":"Multistep forms"},{"location":"components/#adding-an-api-to-the-apiservice","text":"Now that you've added the components tie it together in the following guide click here to see the guide .","title":"Adding an API to the ApiService"},{"location":"frontend/","text":"Front End The front end of the application is what it's all about. Users need an interface to work with. Developing these interfaces is often time-consuming, and that's what the Skeleton App is all about. The Skeleton App is developed with React, particularly the GatsbyJs framework. For the commands below, you need to have NodeJS installed ( see the requirements ) Use the following command from the root folder to spin up the front-end: cd pwa npm install npm run develop Navigate to http://localhost:8000/ to view the app in your browser. If you have the back-end running as well, you can log in with these credentials: Username : test@gateway.local Password: !ChangeMe!","title":"Front End"},{"location":"frontend/#front-end","text":"The front end of the application is what it's all about. Users need an interface to work with. Developing these interfaces is often time-consuming, and that's what the Skeleton App is all about. The Skeleton App is developed with React, particularly the GatsbyJs framework. For the commands below, you need to have NodeJS installed ( see the requirements ) Use the following command from the root folder to spin up the front-end: cd pwa npm install npm run develop Navigate to http://localhost:8000/ to view the app in your browser. If you have the back-end running as well, you can log in with these credentials: Username : test@gateway.local Password: !ChangeMe!","title":"Front End"},{"location":"glossary/","text":"Development of the Skeleton Application This page consists of the following parts: Layout skeleton-app cd pwa/src Pages .tsx file .ts file .module.css file Templates Authenticated template Unauthenticated template Hooks ApiService Resources Services apiContext.ts apiService.ts Glossary This is the go-to for additional explaination in case something is unclear. Pages GatsbyJS is a static web app generator. This means it focusses on a set of pages and renders the components in these pages. This separation ensures blazing fast pages, and provides additional .tsx file A .tsx file is the TypeScript equivalent of the .jsx files used by React. JSX is a syntax extention to JavaScript. Both file types produce React \"elements\". You can read more about JSX in the React documentation .ts file This is a TypeScript file. TypeScript is a superset for JavaScript to make it a strongly typed programming language. Less error prone, tight intergration with editors and native type inference. That's the reason why the Skeleton App uses TypeScript. TypeScript is compiled to regular JavaScript by all browsers. .module.css file CSS modules is a fancy way to tackle the problem of global CSS (which tends to become one big unorganized mess) and to guarantee the (scoped) styling of a single component. The Skeleton app is built with components, so the design choice fell on CSS Modules. Templates To start developing on the Skeleton App with a running start, it comes with various templates right out-of-the-box. When starting up the Skeleton app, you are presented with a choice for your application. Authenticated templates This is variation on the template. Signing in and keeping track of sessions is often cumbersome to implement. Not any more. With the PIP template (Dashboard as well), this is all done for you in the authenticated templates. You do need to spin up the backend as well. The authentication is done through sessionStorage . The mechanics of the authentication can be found in /pwa/src/services/auth.tsx tell about authenticated templates and the use of it add an example with context about what you have to, how you do it and why you have to do it Unauthenticated template If authentication is of no concern, like for instance, the only thing you need is a landing page, choose a unauthenticated template and develop further without the need of a backend or authentication. Hooks React Hooks allow you to reuse stateful logic without changing your component hierarchy. This makes it easy to share Hooks among many components or with the community. Some hooks are native to React and can be imported and used in a file. Not all of these hooks cover every situation where you need them, that's why you can find more custom hooks in pwa/src/hooks . ApiService The apiServices are classes that include advanced functionality, for instance: fucntions that will take care of authentication and CRUD operations. Resources tell about ApiService resource and the use of it Services tell about ApiService services and the use of it apiContext.ts tell about ApiService apiContext.ts file and the use of it apiService.ts tell about ApiService apiService.ts file and the use of it Adding pages to the skeleton-app Now we've looked at the explanation about the structure and files of the skeleton app we can add new pages click here to see the guide .","title":"The layout"},{"location":"glossary/#development-of-the-skeleton-application","text":"This page consists of the following parts: Layout skeleton-app cd pwa/src Pages .tsx file .ts file .module.css file Templates Authenticated template Unauthenticated template Hooks ApiService Resources Services apiContext.ts apiService.ts","title":"Development of the Skeleton Application"},{"location":"glossary/#glossary","text":"This is the go-to for additional explaination in case something is unclear.","title":"Glossary"},{"location":"glossary/#pages","text":"GatsbyJS is a static web app generator. This means it focusses on a set of pages and renders the components in these pages. This separation ensures blazing fast pages, and provides additional","title":"Pages"},{"location":"glossary/#tsx-file","text":"A .tsx file is the TypeScript equivalent of the .jsx files used by React. JSX is a syntax extention to JavaScript. Both file types produce React \"elements\". You can read more about JSX in the React documentation","title":".tsx file"},{"location":"glossary/#ts-file","text":"This is a TypeScript file. TypeScript is a superset for JavaScript to make it a strongly typed programming language. Less error prone, tight intergration with editors and native type inference. That's the reason why the Skeleton App uses TypeScript. TypeScript is compiled to regular JavaScript by all browsers.","title":".ts file"},{"location":"glossary/#modulecss-file","text":"CSS modules is a fancy way to tackle the problem of global CSS (which tends to become one big unorganized mess) and to guarantee the (scoped) styling of a single component. The Skeleton app is built with components, so the design choice fell on CSS Modules.","title":".module.css file"},{"location":"glossary/#templates","text":"To start developing on the Skeleton App with a running start, it comes with various templates right out-of-the-box. When starting up the Skeleton app, you are presented with a choice for your application.","title":"Templates"},{"location":"glossary/#authenticated-templates","text":"This is variation on the template. Signing in and keeping track of sessions is often cumbersome to implement. Not any more. With the PIP template (Dashboard as well), this is all done for you in the authenticated templates. You do need to spin up the backend as well. The authentication is done through sessionStorage . The mechanics of the authentication can be found in /pwa/src/services/auth.tsx tell about authenticated templates and the use of it add an example with context about what you have to, how you do it and why you have to do it","title":"Authenticated templates"},{"location":"glossary/#unauthenticated-template","text":"If authentication is of no concern, like for instance, the only thing you need is a landing page, choose a unauthenticated template and develop further without the need of a backend or authentication.","title":"Unauthenticated template"},{"location":"glossary/#hooks","text":"React Hooks allow you to reuse stateful logic without changing your component hierarchy. This makes it easy to share Hooks among many components or with the community. Some hooks are native to React and can be imported and used in a file. Not all of these hooks cover every situation where you need them, that's why you can find more custom hooks in pwa/src/hooks .","title":"Hooks"},{"location":"glossary/#apiservice","text":"The apiServices are classes that include advanced functionality, for instance: fucntions that will take care of authentication and CRUD operations.","title":"ApiService"},{"location":"glossary/#resources","text":"tell about ApiService resource and the use of it","title":"Resources"},{"location":"glossary/#services","text":"tell about ApiService services and the use of it","title":"Services"},{"location":"glossary/#apicontextts","text":"tell about ApiService apiContext.ts file and the use of it","title":"apiContext.ts"},{"location":"glossary/#apiservicets","text":"tell about ApiService apiService.ts file and the use of it","title":"apiService.ts"},{"location":"glossary/#adding-pages-to-the-skeleton-app","text":"Now we've looked at the explanation about the structure and files of the skeleton app we can add new pages click here to see the guide .","title":"Adding pages to the skeleton-app"},{"location":"pages/","text":"Development of the Skeleton Application This page consists of the following parts: Adding an overview page Adding a detail page These steps require you to: Spin up the front-end of the application . Spin up the backend Adding an overview page An overview page is meant for each unique meaning of a term (or topic). Or they provide free navigation guides for a topic and include a headline, a short definition. You can add a new page with the following steps: Create a new .tsx file for your page at pwa/src/pages/{folder-name}.tsx -Optional:- Add a template to the page (this is not necessary but makes the code base clean and organized) Create a new folder under pwa/src/templates/{folder-name} Create a .tsx file pwa/src/templates/{folder-name}/{File-name}.tsx Create a .module.css file cd pwa/src/templates/{folder-name}/{File-name}.module.css (if nadditional styling is needed on page level) When adding content to the page , select a template based on content. See this doc about the different template types NOTE The breadcrumbs are automatically generated, but this leads to user-unfriendly names in most cases. You can change the names in the gatsby-config.js file. NOTE When creating a folder, Gatsby expects an index.tsx or index.ts file to render the page As an example we will create a folder and file: # create a folder mkdir pwa/src/templates/PetStore # creating a .tsx file in the Petstore folder cd pwa/src/templates/petStore/ touch PetStore.tsx # creating an optional .module.css file touch PetStore.module.css Now with the overview page and template done, let's add the template as an import to the page. The code of the petStore page file looks like this after the imports and component elements: // pwa/src/pages/petStore.tsx import * as React from \"react\"; import { DashboardTemplate } from \"../templates/dashboard/DashboardTemplate\"; //imports import { TestTemplate } from \"../templates/testFolder/TestTemplate\"; // imports const TestPage: React.FC = () => { return ( <DashboardTemplate> <TestTemplate /> </DashboardTemplate> ) }; // Rendering the components export default TestPage; The follow-up is adding a sideNav item for the page to navigate to. You can add this in the DashboardTemplate . Inside the template is a variable called menuItems . Inside this variable, you can add a new item. Once added, your code should look similar to this example: // pwa/src/templates/dashboard/DashboardTemplate.tsx const menuItems: MenuItem[] = [ { label: t(\"Home\"), href: \"/\", current: pathname === \"/\", icon: <GridIcon /> }, { label: t(\"Test page\"), href: \"/testFolder\", current: pathname === \"/testFolder\", icon: <GridIcon /> } ]; Navigate to localhost:8000 and click on the sideNav item 'Test page' to see the following example: Adding a detail page A detail page is meant for a part of a unique topic. Adding a detail page is easily done with the following steps: cd pwa/src/pages mkdir {folder-name} mv pwa/src/pages/petStore.tsx {folder-name} touch [`index.ts`](glossary.md#ts-file) For everything to work, some importing and exporting needs to be done. In this file we are going to import and export the overview page we created cd pwa/src/pages/petStore.tsx @TODO explanation index file import/export The import/ export file code really is nothing more than: // pwa/src/pages/test/index.ts import TestPage from \"./test\"; export default TestPage; Restart the development server and go to localhost:8000/petStore Reinstall the package-json with the following command and start the server again with these commands in the terminal: $ ctrl + C npm install npm start You will see the same result as above. Now it's time to add the detail page In the terminal: cd pwa/src/pages/{folder-name}/[fileId] touch {file-name}.tsx // In `index.ts` we are going to import and export the detail page we created `cd pwa/src/pages/{folder-name}/[fileId]/{file-name}.tsx` touch index.ts mkdir pwa/src/templates/{folder-name} cd pwa/src/templates/{folder-name} touch {file-name}.tsx // Import the template file `cd pwa/src/templates/{folder-name}/{file-name}.tsx` in the detail page `cd pwa/src/pages/{folder-name}/[fileId]/{file-name}.tsx` we added Restart the development server, like in the previous section and go to localhost:8000/petStore/{someId} NOTES : The parentheses around the fileId makes Gatsby view this as a variable {someId} can be anything To change the breadcrumbs , go to the gatsby-config.js file in /pwa/ There's a gatsby-plugin-breadcrumb block in the file. Under the options key, add an array crumbLabelUpdates . You can add an object with pathName and crumbLabel . For the pathName , we can add the folder name as it is. crumbLabel will be the outcome. Here we will edit the breadcrumbs of the two pages we just created. // cd pwa/gatsby-config.js crumbLabelUpdates: [ { pathname: \"/petStore\", crumbLabel: \"Pet store\", }, { pathname: \"/petStore/[petStoreId]\", crumbLabel: \"Pet store detail page\", }, ] Restart the development server. The breadcrumbs should look like this. Adding components to your page Now that you've added the two pages, we can add components to those pages. click here to see the guide .","title":"Adding pages"},{"location":"pages/#development-of-the-skeleton-application","text":"This page consists of the following parts: Adding an overview page Adding a detail page These steps require you to: Spin up the front-end of the application . Spin up the backend","title":"Development of the Skeleton Application"},{"location":"pages/#adding-an-overview-page","text":"An overview page is meant for each unique meaning of a term (or topic). Or they provide free navigation guides for a topic and include a headline, a short definition. You can add a new page with the following steps: Create a new .tsx file for your page at pwa/src/pages/{folder-name}.tsx -Optional:- Add a template to the page (this is not necessary but makes the code base clean and organized) Create a new folder under pwa/src/templates/{folder-name} Create a .tsx file pwa/src/templates/{folder-name}/{File-name}.tsx Create a .module.css file cd pwa/src/templates/{folder-name}/{File-name}.module.css (if nadditional styling is needed on page level) When adding content to the page , select a template based on content. See this doc about the different template types NOTE The breadcrumbs are automatically generated, but this leads to user-unfriendly names in most cases. You can change the names in the gatsby-config.js file. NOTE When creating a folder, Gatsby expects an index.tsx or index.ts file to render the page As an example we will create a folder and file: # create a folder mkdir pwa/src/templates/PetStore # creating a .tsx file in the Petstore folder cd pwa/src/templates/petStore/ touch PetStore.tsx # creating an optional .module.css file touch PetStore.module.css Now with the overview page and template done, let's add the template as an import to the page. The code of the petStore page file looks like this after the imports and component elements: // pwa/src/pages/petStore.tsx import * as React from \"react\"; import { DashboardTemplate } from \"../templates/dashboard/DashboardTemplate\"; //imports import { TestTemplate } from \"../templates/testFolder/TestTemplate\"; // imports const TestPage: React.FC = () => { return ( <DashboardTemplate> <TestTemplate /> </DashboardTemplate> ) }; // Rendering the components export default TestPage; The follow-up is adding a sideNav item for the page to navigate to. You can add this in the DashboardTemplate . Inside the template is a variable called menuItems . Inside this variable, you can add a new item. Once added, your code should look similar to this example: // pwa/src/templates/dashboard/DashboardTemplate.tsx const menuItems: MenuItem[] = [ { label: t(\"Home\"), href: \"/\", current: pathname === \"/\", icon: <GridIcon /> }, { label: t(\"Test page\"), href: \"/testFolder\", current: pathname === \"/testFolder\", icon: <GridIcon /> } ]; Navigate to localhost:8000 and click on the sideNav item 'Test page' to see the following example:","title":"Adding an overview page"},{"location":"pages/#adding-a-detail-page","text":"A detail page is meant for a part of a unique topic. Adding a detail page is easily done with the following steps: cd pwa/src/pages mkdir {folder-name} mv pwa/src/pages/petStore.tsx {folder-name} touch [`index.ts`](glossary.md#ts-file) For everything to work, some importing and exporting needs to be done. In this file we are going to import and export the overview page we created cd pwa/src/pages/petStore.tsx @TODO explanation index file import/export The import/ export file code really is nothing more than: // pwa/src/pages/test/index.ts import TestPage from \"./test\"; export default TestPage; Restart the development server and go to localhost:8000/petStore Reinstall the package-json with the following command and start the server again with these commands in the terminal: $ ctrl + C npm install npm start You will see the same result as above. Now it's time to add the detail page In the terminal: cd pwa/src/pages/{folder-name}/[fileId] touch {file-name}.tsx // In `index.ts` we are going to import and export the detail page we created `cd pwa/src/pages/{folder-name}/[fileId]/{file-name}.tsx` touch index.ts mkdir pwa/src/templates/{folder-name} cd pwa/src/templates/{folder-name} touch {file-name}.tsx // Import the template file `cd pwa/src/templates/{folder-name}/{file-name}.tsx` in the detail page `cd pwa/src/pages/{folder-name}/[fileId]/{file-name}.tsx` we added Restart the development server, like in the previous section and go to localhost:8000/petStore/{someId} NOTES : The parentheses around the fileId makes Gatsby view this as a variable {someId} can be anything To change the breadcrumbs , go to the gatsby-config.js file in /pwa/ There's a gatsby-plugin-breadcrumb block in the file. Under the options key, add an array crumbLabelUpdates . You can add an object with pathName and crumbLabel . For the pathName , we can add the folder name as it is. crumbLabel will be the outcome. Here we will edit the breadcrumbs of the two pages we just created. // cd pwa/gatsby-config.js crumbLabelUpdates: [ { pathname: \"/petStore\", crumbLabel: \"Pet store\", }, { pathname: \"/petStore/[petStoreId]\", crumbLabel: \"Pet store detail page\", }, ] Restart the development server. The breadcrumbs should look like this.","title":"Adding a detail page"},{"location":"pages/#adding-components-to-your-page","text":"Now that you've added the two pages, we can add components to those pages. click here to see the guide .","title":"Adding components to your page"}]}